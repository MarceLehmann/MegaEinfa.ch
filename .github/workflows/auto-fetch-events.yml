name: Auto-Fetch Events from Logic App

# Läuft täglich um 8:00 UTC (10:00 CEST)
on:
  schedule:
    - cron: '0 8 * * *'
  # Ermöglicht manuelles Ausführen
  workflow_dispatch:
  # Läuft auch bei Push (für Testing)
  push:
    branches: [ main, master ]
    paths:
      - '.github/workflows/auto-fetch-events.yml'

permissions:
  contents: write  # Benötigt für git push
  actions: read    # Benötigt für Workflow-Ausführung

jobs:
  fetch-and-update-events:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Fetch events from Logic App
      id: fetch-events
      run: |
        echo "🔄 Fetching events from Logic App..."
        
        # HTTP GET Request an Azure Logic App
        RESPONSE=$(curl -s -w "HTTP_CODE:%{http_code}" -X GET \
          "https://prod-25.switzerlandnorth.logic.azure.com:443/workflows/2d4664dae4a8477583ae88ce5a4cf570/triggers/manual/paths/invoke?api-version=2016-06-01&sp=%2Ftriggers%2Fmanual%2Frun&sv=1.0&sig=oHWCdT2HSCOQ3j1gQOYJPg9e07eFR44xSIGbvyBl2OM" \
          -H "Content-Type: application/json")
        
        # Extrahiere HTTP Status Code
        HTTP_CODE=$(echo "$RESPONSE" | grep -o "HTTP_CODE:[0-9]*" | cut -d: -f2)
        JSON_RESPONSE=$(echo "$RESPONSE" | sed 's/HTTP_CODE:[0-9]*$//')
        
        echo "� HTTP Status: $HTTP_CODE"
        echo "�📥 Response from Logic App:"
        
        if [ "$HTTP_CODE" != "200" ]; then
          echo "❌ Logic App returned error code: $HTTP_CODE"
          echo "Response: $JSON_RESPONSE"
          echo "has_new_events=false" >> $GITHUB_OUTPUT
          exit 0  # Don't fail the workflow, just skip processing
        fi
        
        # Prüfe ob die Response gültiges JSON ist
        if ! echo "$JSON_RESPONSE" | jq empty > /dev/null 2>&1; then
          echo "❌ Invalid JSON response from Logic App"
          echo "Response: $JSON_RESPONSE"
          echo "has_new_events=false" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        echo "$JSON_RESPONSE" | jq '.'
        
        # Prüfe ob neue Events vorhanden sind
        NEW_EVENTS=$(echo "$JSON_RESPONSE" | jq -r '.New // empty')
        
        if [ "$NEW_EVENTS" = "null" ] || [ -z "$NEW_EVENTS" ] || [ "$NEW_EVENTS" = "[]" ]; then
          echo "ℹ️ Keine neuen Events gefunden."
          echo "has_new_events=false" >> $GITHUB_OUTPUT
        else
          echo "✅ Neue Events gefunden!"
          echo "has_new_events=true" >> $GITHUB_OUTPUT
          echo "$NEW_EVENTS" > new_events.json
        fi
    
    - name: Setup Node.js
      if: steps.fetch-events.outputs.has_new_events == 'true'
      uses: actions/setup-node@v4
      with:
        node-version: '18'
    
    - name: Process and add new events
      if: steps.fetch-events.outputs.has_new_events == 'true'
      run: |
        echo "🔧 Processing new events..."
        
        # Node.js Script für die Verarbeitung
        cat > process_events.js << 'EOF'
        const fs = require('fs');
        const path = require('path');
        const yaml = require('js-yaml');
        
        try {
          // Lade neue Events
          const newEvents = JSON.parse(fs.readFileSync('new_events.json', 'utf8'));
          console.log('📋 Neue Events:', JSON.stringify(newEvents, null, 2));
          
          // Lade aktuelle upcoming_events.yml
          const eventsFilePath = '_data/upcoming_events.yml';
          let eventsContent = '';
          let existingEvents = [];
          
          if (fs.existsSync(eventsFilePath)) {
            eventsContent = fs.readFileSync(eventsFilePath, 'utf8');
            
            // Extrahiere Header-Kommentare (alles vor dem ersten Event)
            const lines = eventsContent.split('\n');
            const headerLines = [];
            let foundFirstEvent = false;
            
            for (const line of lines) {
              if (line.trim().startsWith('- title:') && !foundFirstEvent) {
                foundFirstEvent = true;
                break;
              }
              headerLines.push(line);
            }
            
            // Parse existierende Events (nur YAML-Teil ohne Kommentare)
            const yamlPart = eventsContent.substring(headerLines.join('\n').length).trim();
            if (yamlPart) {
              try {
                existingEvents = yaml.load(yamlPart) || [];
              } catch (e) {
                console.log('⚠️ Konnte existierende Events nicht parsen, erstelle neue Liste');
                existingEvents = [];
              }
            }
          }
          
          // Konvertiere neue Events ins richtige Format
          const convertedEvents = newEvents.map(event => {
            // Parse ISO Date
            const eventDate = new Date(event.date);
            const formattedDate = eventDate.toISOString().split('T')[0]; // YYYY-MM-DD
            
            // LinkedIn-Link: Verwende aus JSON oder generiere fallback
            let linkedinUrl = event.linkedin;
            if (!linkedinUrl && event.presenter) {
              linkedinUrl = `https://www.linkedin.com/in/${event.presenter.toLowerCase().replace(/\s+/g, '-')}/`;
            }
            
            return {
              title: event.title.replace(/^"MegaEinfa\.ch - PowerPlatform erklärt" - /, ''),
              date: formattedDate,
              time: event.time || "10:00 - 11:30", // Verwende aus JSON oder Default
              presenter: event.presenter,
              linkedin: linkedinUrl,
              description: event.description || `Spannende Session mit ${event.presenter} über PowerPlatform Themen.`,
              registration_link: event.registration_link || "https://example.com/register",
              status: event.status || "Bald verfügbar"
            };
          });
          
          // Prüfe auf Duplikate (gleicher Titel und Datum)
          const newUniqueEvents = convertedEvents.filter(newEvent => {
            return !existingEvents.some(existingEvent => 
              existingEvent.title === newEvent.title && 
              existingEvent.date === newEvent.date
            );
          });
          
          if (newUniqueEvents.length === 0) {
            console.log('ℹ️ Alle Events existieren bereits - keine neuen Events hinzugefügt.');
            process.exit(0);
          }
          
          console.log(`✅ ${newUniqueEvents.length} neue Events werden hinzugefügt`);
          
          // Füge neue Events hinzu und sortiere nach Datum
          const allEvents = [...existingEvents, ...newUniqueEvents]
            .sort((a, b) => new Date(a.date) - new Date(b.date));
          
          // Erstelle Header-Kommentare
          const header = `# ========================================
# UPCOMING EVENTS - Zukünftige Termine
# ========================================
# 
# Template für neue Termine (einfach kopieren und anpassen):
#
# - title: "Titel der Veranstaltung"
#   date: "2025-07-15"  # Format: YYYY-MM-DD
#   time: "10:00 - 11:30"
#   presenter: "Name des Präsentators"
#   linkedin: "https://www.linkedin.com/in/presenter-name/"  # LinkedIn-Profil des Präsentators
#   description: "Beschreibung was behandelt wird und was die Teilnehmer lernen..."
#   registration_link: "https://link-zur-anmeldung.com"  # Optional
#   status: "Anmeldung offen"  # Optionen: "Anmeldung offen", "Bald verfügbar", "Planung"
#
# Status-Optionen:
# - "Anmeldung offen" = Grüner Badge + Anmelde-Button
# - "Bald verfügbar"  = Gelber Badge
# - "Planung"         = Oranger Badge
#
# ========================================

`;
          
          // Schreibe aktualisierte Events-Datei
          const updatedContent = header + yaml.dump(allEvents, {
            lineWidth: -1,
            noArrayIndent: false,
            quotingType: '"'
          });
          
          fs.writeFileSync(eventsFilePath, updatedContent, 'utf8');
          
          console.log('📝 Events-Datei erfolgreich aktualisiert!');
          
          // Erstelle Commit-Message mit Details
          const eventTitles = newUniqueEvents.map(e => e.title).join(', ');
          fs.writeFileSync('commit_message.txt', `🎉 Neue Events automatisch hinzugefügt: ${eventTitles}`, 'utf8');
          
        } catch (error) {
          console.error('❌ Fehler beim Verarbeiten der Events:', error);
          process.exit(1);
        }
        EOF
        
        # Installiere js-yaml
        npm install js-yaml
        
        # Führe das Script aus
        node process_events.js
    
    - name: Commit and push changes
      if: steps.fetch-events.outputs.has_new_events == 'true'
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        # Prüfe ob Änderungen vorhanden sind
        if git diff --quiet && git diff --staged --quiet; then
          echo "ℹ️ Keine Änderungen zu committen."
          exit 0
        fi
        
        # Commit changes
        git add _data/upcoming_events.yml
        
        if [ -f commit_message.txt ]; then
          COMMIT_MSG=$(cat commit_message.txt)
        else
          COMMIT_MSG="🎉 Automatisches Update: Neue Events hinzugefügt"
        fi
        
        git commit -m "$COMMIT_MSG"
        git push
        
        echo "✅ Änderungen erfolgreich gepusht!"
    
    - name: Summary
      run: |
        echo "## Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        if [ "${{ steps.fetch-events.outputs.has_new_events }}" = "true" ]; then
          echo "🎉 **Erfolgreich abgeschlossen!** Neue Events wurden automatisch hinzugefügt." >> $GITHUB_STEP_SUMMARY
          echo "🎉 **Erfolgreich abgeschlossen!** Neue Events wurden automatisch hinzugefügt."
        else
          echo "ℹ️ **Keine Aktion erforderlich** - Keine neuen Events gefunden." >> $GITHUB_STEP_SUMMARY
          echo "ℹ️ **Keine Aktion erforderlich** - Keine neuen Events gefunden."
        fi
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Workflow completed at:** $(date)" >> $GITHUB_STEP_SUMMARY
